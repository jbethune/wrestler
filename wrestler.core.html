<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>wrestler.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">wRESTler 2.0.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wrestler</span></div></div></li><li class="depth-2 branch current"><a href="wrestler.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="wrestler.handlers.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>handlers</span></div></a></li><li class="depth-2"><a href="wrestler.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="wrestler.core.html#var-defREST"><div class="inner"><span>defREST</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">wrestler.core</h2><div class="doc"><div class="markdown"><p>A library for defining REST client wrappers for webservices.</p><p>Defining a wrapper consists of the following steps:</p>
<ol>
  <li>Define a default <code>base-url</code> and a default <code>response-handler</code> as atoms</li>
  <li>Create a new wrapper factory with <code>defREST</code> and choose a name for it</li>
  <li>Define the individual wrappers with the wrapper factory</li>
  <li>Ship it to end users who can then <code>(reset!)</code> the <code>base-url</code> and the  <code>response-handler</code> if necessary.</li>
</ol><p>In detail this means the following:</p><h1>Step 1: Define <code>base-url</code> and <code>response-handler</code></h1><p>Let us assume that every request to the REST API starts with the following URL: <a href="http://example.com/rest/">http://example.com/rest/</a>. Then you should define the following atom:</p>
<pre><code>(def base-url (atom &quot;http://example.com/rest/&quot;))
</code></pre><p>And you need to define a function that will handle responses from the server and wrap this function with an atom:</p>
<pre><code>(def response-handler (atom
                        (fn [response]
                           (print &quot;Got an answer from the server!&quot;)
                           (:body response))))
</code></pre><p>The <code>response</code> parameter is a hash-map returned by the clj-http library (<a href="https://github.com/dakrone/clj-http/">https://github.com/dakrone/clj-http/</a>)</p><p>Alternatively you can just use one of the handlers from <a href="wrestler.handlers.html"><code>wrestler.handlers</code></a> but don&rsquo;t forget to call (atom) on them.</p><h1>Step 2: Create a new wrapper factory</h1>
<pre><code>(defREST
  defMyAPI; This is the name of your new API wrapper
 &#39;current-namespace/base-url
 &#39;current-namespace/response-handler)
</code></pre><p>Note the fully-qualified and quoted form of the <code>base-url</code> and <code>response-handler</code> atoms. These are required for the macros to work properly when they are used in the context of a different namespace (If you know a cleaner solution, I&rsquo;d love to hear it!)</p><p>Next, we will see how to use it.</p><h1>Step 3: Define the individual wrappers</h1><p>Create the individual wrappers</p>
<pre><code>(defMyAPI get-database-size
&quot;This is a mandatory docstring that describes the new function get-database-size&quot;
:get &quot;subpath/that/is/appended/to/base-url/&quot;)
</code></pre><p>The newly created wrapper factory <code>defMyAPI</code> has the following parameters:</p>
<ol>
  <li>Name of the wrapper function that will be created: <code>get-database-size</code></li>
  <li>Docstring of the wrapper function that will be created: <code>&quot;This is a mandatory...&quot;</code></li>
  <li>HTTP method. Pick one of <code>:get :post :put :del</code>. Here it&rsquo;s <code>:get</code></li>
  <li>URL extension to the base URL. The base url and this URL will be glued  together. This extension URL can also contain positional parameters  defined with a leading $ (more on that later):  <code>&quot;subpath/that/is/appended/...&quot;</code></li>
</ol><p>You would call this function just like this:</p>
<pre><code>(get-database-size)
</code></pre><p>Another example:</p>
<pre><code>(defMyAPI create-new-database
&quot;Write documentation here

(url param) name: Name of the new database
(query param) size: Initial size of the database

Some more documentation text.&quot;
:post &quot;create_database/$name&quot;)
</code></pre><p>All normal positional parameters are defined with a $ followed by the name of the parameter. In this example the only parameter is called &ldquo;name&rdquo; and is written as <code>$name</code>. Parameter names expand up to the nearest slash or dot (<code>/</code> or <code>.</code>). You can have as many url parameters as you like: <code>literal/$var1/$var2/literal/$var3.zip</code></p><p>Further parameters that are being passed to the function are treated as key-value pairs and are turned into query parameters unless one of the keys is a special key like <code>:json</code>.</p><p>So if you call the function like this:</p>
<pre><code>(create-new-database &quot;all-my-data&quot; :initial-size 42 :cache 1)
</code></pre><p>The URL <code>@base-url</code> + <code>create_database/all-my-data?initial-size=42&amp;cache=1</code> will be requested. While it is usually more clojurerish to use keywords as keys, you can also use strings as keys if that is more convenient for you.</p><p>Sometimes you need to send some payload in addition to your request. The most popular way to do this nowadays is to use JSON. In order to send JSON data to the server, simply pass a <code>:json</code> key and some clojure value as additional arguments to a function call. Example:</p>
<pre><code>(defMyAPI enter-data
&quot;Enter data into the database

(url param) location: location where data should be entered
(query param) method: How to process the data that should be stored
(query param) reference: Reference to use for filling in missing data
(json param) data: A vector of hash-maps each containing the keys &quot;name&quot; and &quot;value&quot;
(json param) user: A string containing your user id as the author of your data&quot; ; end of docstring
:post &quot;enter_data/$location/&quot;)
</code></pre><p>And you would call it like this:</p>
<pre><code>(enter-data
 &quot;my-folder&quot;; positional parameter location
 :method &quot;make fancy&quot; :reference &quot;old dataset&quot;;regular query paramters
 :json {&quot;data&quot; [{&quot;name&quot; &quot;Earth&quot; &quot;value&quot; &quot;mostly harmless&quot;}]
        &quot;user&quot; &quot;Ford Perfect&quot;}); JSON parameters
</code></pre><p>Note that the JSON parameters are just Clojure values. They will be converted to JSON automatically.</p><p>And also note that we did not specify explicitly that the function can take JSON values. All functions created with wRESTler support sending additional query values and JSON values by default. This design decision was made because some REST APIs have optional query and/or JSON parameters. To make wRESTler REPL-friendly I decided to use varargs for query and JSON parameters at the same time. This leads to slightly less arity checking but should make your workflow much nicer and your code more readable.</p><p>Thus, my advice is to just write all mandatory and optional parameters in the docstring so that the user can see how to use a wrapper function. If the user doesn&rsquo;t use the wrapper correctly the server will probably return an error message. In this case the docstring should explain how to use the wrapper properly.</p><h1>Step 4: Ship it</h1><p>Publish your wrapper on Clojars. I won&rsquo;t explain the details here but I want to emphasize the importance of your <code>base-url</code> and your <code>response-handler</code> being atoms. By making them atoms, they can be changed by the user to let them point to a different URL or to behave differently when a response is received. So it&rsquo;s very important to explain to your users how to access these two atoms so that they can configure them for their purposes.</p><p>If you like to see more examples on how to use the library, have a look at cyrest-clojure (<a href="http://github.com/jbethune/cyrest-clojure)">http://github.com/jbethune/cyrest-clojure)</a>.</p></div></div><div class="public anchor" id="var-defREST"><h3>defREST</h3><h4 class="type">macro</h4><div class="usage"><code>(defREST api-name base-url response-handler)</code></div><div class="doc"><pre class="plaintext">Declare a new rest API of name api-name with two atoms(!) that contain the
base-url (common URL prefix of all REST requests for that API) and a response
handler function that knows how to work with clj-http responses.
By using this macro a new macro will be created with the name api-name which
captures the two atoms that you have provided.
For a detailed explanation how to use this macro, read this docstring of the
wrestler.core namespace.</pre></div></div></div></body></html>